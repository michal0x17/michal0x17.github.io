---
layout: post
title:  "Wytwarzanie oprogramowania I - paradygmaty programowania"
date:   2016-07-02 06:05:10 -0700
---

Jest to pierwszy wpis z serii, którą nazwałem 'Wytwarzanie oprogramowania'. W serii tej, postaram się przedstawić elementy, które pomagają zrozumieć mi czym jest programowanie, a także elementy, które pomogły\pomagają mi w codziennej pracy, od momentu kiedy byłem młodszym programistą do teraz, kiedy jestem trochę starszym programistą ;).

Wpis ten zawiera krótki przegląd wybranych paradygmatów programowania.

## Programowanie niskopoziomowe
### Język maszynowy
Z punktu widzenia komputera najbardziej przyjazym językiem do komunikacji jest język składający się z dwóch znaków: 0 i 1. Jest to tak zwany język maszynowy. "Rozmowa" z komputerem w tym języku odbywa się poprzez wprowadzanie rozkazów reprezentowanych jako ciągi zer i jedynek. Każdy komputer posiada jednostkę zwaną procesorem, a każdy rodzaj procesora posiada swoją intepretację języka maszynowego. Dla przykładu poniższy kod reprezetuje język maszynowy zrozumiały dla procesora Sextium II (wpisać autora)(dać linka do definicji). "Rozkazuje" on komputerowi wczytanie dwóch liczb ze standardowego wejścia, dododanie ich do siebie, oraz wypisanie wyniku na standardowe wyjście:

{% highlight plaintext %}
000000000000000 1010 0101 0011 0010
000000000000001 0000 0000 0000 1001
000000000000010 1010 0101 0011 0010
000000000000011 0000 0000 0001 1010
000000000000100 1010 0101 0001 0110
000000000000101 0000 0000 0000 1001
000000000000110 1010 0101 0001 1011
000000000000111 0000 0000 0000 1010
000000000001000 1011 0100 1111 0000
000000000001001 0000 0000 0000 0000
000000000001010 0000 0000 0000 0000
{% endhighlight %}

Wersja w zapisie 16-kowym
{% highlight plaintext %}
0000 A532
0001 0009
0002 A532
0003 000A
0004 9516
0005 0009
0006 951B
0007 000A
0008 4F00
0009 0000
000A 0000
{% endhighlight %}

### Asembler
Dla komputera powyższy kod jest jasny i łatwy w zrozumieniu, natomiast dla człowieka już nie (a może tak ;)) dlatego następnym etapem w rozwoju języków programowania było powstanie tak zwanych języków adresów symbolicznych (Asemblerów). Program napisany w takim języku, reprezentowany jest w postaci symboli, które reprezentują rozkazy procesora. Symbole te  nastepnie tłumaczone są na język maszynowy procesora. Poniższy kod jest tym samym programem z poprzedniego akapitu, napisanym w języku asemblera zrozumiałego dla procesora Sextium II:

{% highlight plaintext %}
0000 CONST SWAPA READ STORE
0001 0009 #adres zmiennej x
0002 CONST SWAPA READ STORE
0003 000A #adres zmiennej y
0004 CONST SWAPA LOAD SWAPD
0005 0009 #adres zmiennej x
0006 CONST SWAPA LOAD ADD
0007 000A #adres zmiennej y
0008 WRITE HALT NOP NOP
0009 #miejsce przechowywania zmiennej x
000A #miejsce przechowywania zmiennej y
{% endhighlight %}

## Języki wysokiego poziomu
Asembler pozwala komunikować się z komputerem w dużo bardziej przyjazny sposób niż ciągi zer i jedynek, umożliwiając pisanie bardziej zaawansowanych programów. Jednak nadal jest to język dość trudny, zwłaszcza jesli chodzi o analizę kodu lub jego modyfikację. Między innymi z tego powodu, następnym krokiem w rozwoju języków programowania było powstanie tak zwanych języków wysokiego poziomu. Języki te umożliwiają porozumiewanie się z komputerem w jeszcze bardziej przyjazny sposób, uwalniając programistę od konieczności znajomości konkretnej architektury procesora. Kod napisany w języku wysokiego poziomu jest tłumaczony na język asemblera (lub bezpośrednio na język maszynowy) w tak zwanym procesie kompilacji. Jednym z pierwszych stworzynych języków z tej kateogri jest język o nazwie Fortran (wpisać autora). Niektóre cechy to:
* deklaracje zmiennych
* definiowanie procedur
* operatory logiczne
* operatory arytmetyczne
* operatory działań na liczbach

Poniższy kod jest tym samym programem z poprzedniego akapitu napisanym w języku Fortran:

{% highlight fortran %}
IMPLICIT NONE
INTEGER :: x,y
READ * ,x,y
PRINT * ,'wynik',x+y
END
{% endhighlight %}

## Programowanie imperatywne
Dzięki językom wysokiego poziomu komunikacja z komputerem została mocno uproszczona w stosunku do języka asemblera, przez co analiza programów oraz ich modifkacja jest dużo prostsza i mniej podatna na błędy. Na bazie takiego poziomu abstrakcji, powstały różnego rodzaju paradygmaty (lub metodyki) programowania. Jednym z takich paradygmatów jest tzw. programowanie imperatywne, ktore charakteryzuje się tym, że program reprezentowany jest w postaci stanu maszyny, który zmieniamy jest przez ciąg instrukcji. Innymi słowy programując imperatywnie mówimy komputerowi jak ma rozwiązać dany problem. Przykładowo poniższy kod napisany w języku C obliczna sumę kwadratów liczb od 1 do n:

{% highlight c %}
#include <stdio.h>

int main()
{
  int n = 10;
  int sum = 0;
  int i = 1;

  loop:
    if (i > n)
    {
      goto end;
    }		

    sum += i*i;
    i += 1;
    goto loop;

  end:;

  printf("%i\n", sum);
}
{% endhighlight %}

## Programowanie strukturalne
Patrząc na powyższy przykład, można zauważyć, że wykorzystuje on tak zwaną instrukcję skoku ("goto"). Instrukcja ta nakazuje komputerowi, przy spełnieniu odpowiednich warunków,  przejście do odpowiedniej części programu i kontynowanie wykonywania programu od tego miejsca. Takie "skakanie" bardzo utrudnia analizę kodu. Paradygmat programowania strukturalnego ogranicza używanie instrukcji skoku, oraz definiuje strukturę kodu. Kod taki powinień składać się z kilku dobrze zdefiniowanych instrukcji:
* Sekwencja – wykonanie instrukcji jedna po drugiej
* Wybór – if-then-else
* Iteracja – for, while

Przykład obliczania sumy kwadratów liczb od 1 do n z użyciem powyższych instrukcji może wyglądać np. tak:

{% highlight c %}
#include <stdio.h>

int main()
{
  int n = 10;
  int sum = 0;
  for (int i = 1; i <= n; i++)
  {
    sum += i*i;
  }

  printf("%i\n", sum);
}
{% endhighlight %}

## Programowanie proceduralne
Głównym założeniem tego paradygmatu jest to aby kod dzielić na mniejsze kawałki, wykonujące jasno określone operacje. Większość języków wysokiego poziomu (a może wszystkie ;)) dostarczają konstrukcje zwane procedurami. W procedurach można zakodować poszczególne fragmenty programu, tak aby odseparować je od reszty, a także móc je wykorzystać w innych miejscach. Przykład podziału na procedury powyższego porgramu może wyglądać np. tak:

{% highlight c %}
#include <stdio.h>

int square(int i)
{
  return i*i;
}

int sumOfSquares(int n)
{
  int sum = 0;
  for (int i = 1; i <= n; i++)
  {
    sum += square(i);
  }

  printf("%i\n", sum);
}

int main()
{
  sumOfSquares(10);
}
{% endhighlight %}

## Programowanie obiektowe
Pewną trudnością w programowaniu proceduralnym jest to, że dane na których operują procedury nie są ze sobą powiązane. Dotyczy to zwłaszcza zadeklarowanych zmiennych globalnych, do których można mieć dostęp z dowolnego fragmentu kodu. Ponieważ główną koncepcja programowania imperatywnego, a co za tym idzie również programowania proceduralnego, jest zmiana stanu maszyny, a stan ten może być zmieniany w dowolnym fragmencie kodu, może prowadzić to do powstawania błędów w programie, poprzez nieprawidłowe ustawienie tegoż stanu. Przeważnie nieumyślne.  Aby zminimalizować takie operacje, powstały tzw. jezyki obiektowe a co za tym idzie również paradygmat programowania obiektowego. Głównym założeniem tego paradygmatu jest to aby dane oraz procedury które operują na tych danych były ze sobą powiązane w takim sensie, aby zmiany na tych danych mogły dokonywać tylko te jasno określone procedury. W większości języków obiektowych konstrukcja do budowy takich powiązań nazwya się klasą (class), a instancję konkretnej klasy nazywa się obiektem (object). Procedury operujące na danych obiektu nazywa się metodami (method). Przykład programu obliczającego sumę kwadratów liczb od 1 do n może wyglądac np. tak:

{% highlight csharp %}
public void Main()
{
  var sumOfSquaresCalculator = new SumOfSquaresCalculator(10);
  var sum = calc.Calculate();
  printf("%i\n", sum);
}

public class SumOfSquaresCalculator
{
  private int n;

  public class SumOfSquaresCalculator(int n)
  {
    this.n = n;
  }

  public int Calculate()
	{
		return this.SumOfSquares();
	}

	private int SumOfSquares()
	{
    int sum = 0;
    for (int i = 1; i <= this.n; i++)
    {
      sum += Square(i);
    }
  }

	private int Square(int i)
  {
    return i*i;
  }
}
{% endhighlight %}

W metodzie 'Main' jest tworzony obiekt SumOfSquaresCalculator, na którym to obiekcie wywoływana jest metoda calculate. Metoda ta jest zadeklarowana jako publiczna w klasie SumOfSquaresCalculator. Pozostałe metody są oznaczone modyfikatorem dostępu private, który to modyfikator "zabrania" dostępu do tych metod, fragmentom kodu innym niż te które znajdują się w klasie SumOfSquaresCalculator. Jak widać na przykładzie w ramach implementacji klasy, wykorzystane jest programowanie proceduralne, ale mogłoby być użyte dowolne inne. "Na zewnątrz klasy" dostępna jest tylko metoda Calculate, a konsumer wywołujący tę metodę nie musi nic wiedzieć o szczegółach jej wewnętrzenej implementacji.

## Programowanie funkcyjne
Rownolegle z rozwojem paradygmatów bazujacych na programuwaniu imperatywnym, rozwijała się koncepcja programowania funkcyjengo. W programowniu imperatywym, główną koncepcją jest stan maszyny oraz zmiana tego stanu, natomiast w programowaniu funkcyjnym główną koncepcją jest funkcja oraz wyliczanie wyrażeń przez funkcje. W większość przypadków języki funkcyjne są bardziej zwięzłe w konstrukacji od języków imperatywnych. Dla porównania przykład programu obliczającego sumę kwadratów liczb od 1 do n, zapisany w języku Haskell może wyglądać np. tak:

{% highlight ocaml %}
    (wstawić przykład).
{% endhighlight %}

## Programowanie logiczne
Jeszcze innym paradygmatem jest tzw. programowanie logiczne, gdzie program reprezentowany jest przez  zapis stwierdzeń rachunku predykatów pierwszego rzędu, a wyniki programu jako rezultat automatycznego wnioskowania z tych stwierdzeń. Przykład programu stwierdzającego relację rodzeństwo w języku Prolog:

{% highlight prolog %}
    (wstawić przykład).
{% endhighlight %}

## Podsumowanie
Nawet bardzo dobra znajnowść języków programowania oraz paradygmatów programowania nie wystarcza do tworzenia programów cechujących się dobrą jakością. W kolejnych seriach z cyklu 'Wytwarzanie oprogramowania' zostaną opisane wybrane techniki pozwalające zbliżyć się do jakości akceptowalnej przez odbiorcę. Bo przecież nie istnieją programy w 100% odporne na błędy, a może tak ;).
