---
layout: post
title:  "Wytwarzanie oprogramowania I - paradygmaty programowania"
date:   2016-07-02 06:05:10 -0700
---

Jest to pierwszy wpis z serii, którą nazwałem 'Wytwarzanie oprogramowania'. W serii tej, postaram się przedstawić elementy, które pomagają zrozumieć mi czym jest programowanie, a także elementy, które pomogły\pomagają mi w codziennej pracy, od momentu kiedy byłem młodszym programistą do teraz, kiedy jestem trochę starszym programistą ;).

Wpis ten zawiera krótki przegląd wybranych paradygmatów programowania.

## Programowanie niskopoziomowe
### Język maszynowy
Z punktu widzenia komputera najbardziej przyjazym językiem do komunikacji jest język składający się z dwóch znaków: 0 i 1. Jest to tak zwany język maszynowy. "Rozmowa" z komputerem w tym języku odbywa się poprzez wprowadzanie rozkazów reprezentowanych jako ciągi zer i jedynek. Każdy komputer posiada jednostkę zwaną procesorem, a każdy rodzaj procesora posiada swoją intepretację języka maszynowego. Dla przykładu poniższy kod reprezetuje język maszynowy zrozumiały dla procesora Sextium II (wpisać autora)(dać linka do definicji). "Rozkazuje" on komputerowi wczytanie dwóch liczb ze standardowego wejścia, dododanie ich do siebie, oraz wypisanie wyniku na standardowe wyjście:

{% highlight c %}
000000000000000 1010 0101 0011 0010
000000000000001 0000 0000 0000 1001
000000000000010 1010 0101 0011 0010
000000000000011 0000 0000 0001 1010
000000000000100 1010 0101 0001 0110
000000000000101 0000 0000 0000 1001
000000000000110 1010 0101 0001 1011
000000000000111 0000 0000 0000 1010
000000000001000 1011 0100 1111 0000
000000000001001 0000 0000 0000 0000
000000000001010 0000 0000 0000 0000
{% endhighlight %}

Wersja w zapisie 16-kowym
{% highlight c %}
0000 A532
0001 0009
0002 A532
0003 000A
0004 9516
0005 0009
0006 951B
0007 000A
0008 4F00
0009 0000
000A 0000
{% endhighlight %}

### Asembler
Dla komputera powyższy kod jest jasny i łatwy w zrozumieniu, natomiast dla człowieka już nie (a może tak ;)) dlatego następnym etapem w rozwoju języków programowania było powstanie tak zwanych języków adresów symbolicznych (Asemblerów). Program napisany w takim języku, reprezentowany jest w postaci symboli, które reprezentują rozkazy procesora. Symbole te  nastepnie tłumaczone są na język maszynowy procesora. Poniższy kod jest tym samym programem z poprzedniego akapitu, napisanym w języku asemblera zrozumiałego dla procesora Sextium II:

{% highlight c %}
0000 CONST SWAPA READ STORE
0001 0009 #adres zmiennej x
0002 CONST SWAPA READ STORE
0003 000A #adres zmiennej y
0004 CONST SWAPA LOAD SWAPD
0005 0009 #adres zmiennej x
0006 CONST SWAPA LOAD ADD
0007 000A #adres zmiennej y
0008 WRITE HALT NOP NOP
0009 #miejsce przechowywania zmiennej x
000A #miejsce przechowywania zmiennej y
{% endhighlight %}

## Języki wysokiego poziomu
Asembler pozwala komunikować się z komputerem w dużo bardziej przyjazny sposób niż ciągi zer i jedynek, umożliwiając pisanie bardziej zaawansowanych programów. Jednak nadal jest to język dość trudny, zwłaszcza jesli chodzi o analizę kodu lub jego modyfikację. Między innymi z tego powodu, następnym krokiem w rozwoju języków programowania było powstanie tak zwanych języków wysokiego poziomu. Języki te umożliwiają porozumiewanie się z komputerem w jeszcze bardziej przyjazny sposób, uwalniając programistę od konieczności znajomości konkretnej architektury procesora. Kod napisany w języku wysokiego poziomu jest tłumaczony na język asemblera (lub bezpośrednio na język maszynowy) w tak zwanym procesie kompilacji. Jednym z pierwszych stworzynych języków z tej kateogri jest język o nazwie Fortran (wpisać autora). Niektóre cechy to:
* deklaracje zmiennych
* definiowanie procedur
* operatory logiczne
* operatory arytmetyczne
* operatory działań na liczbach

Poniższy kod jest tym samym programem z poprzedniego akapitu napisanym w języku Fortran:

{% highlight fortran %}
IMPLICIT NONE
INTEGER :: x,y
READ * ,x,y
PRINT * ,'wynik',x+y
END
{% endhighlight %}

## Programowanie imperatywne
Dzięki językom wysokiego poziomu komunikacja z komputerem została mocno uproszczona w stosunku do języka asemblera, przez co analiza programów oraz ich modifkacja jest dużo prostsza i mniej podatna na błędy. Na bazie takiego poziomu abstrakcji, powstały różnego rodzaju paradygmaty (lub metodyki) programowania. Jednym z takich paradygmatów jest tzw. programowanie imperatywne, ktore charakteryzuje się tym, że program reprezentowany jest w postaci stanu maszyny, który zmieniamy jest przez ciąg instrukcji. Innymi słowy programując imperatywnie mówimy komputerowi jak ma rozwiązać dany problem. Przykładowo poniższy kod napisany w języku C obliczna sumę kwadratów liczb od 1 do n:

{% highlight c %}
#include <stdio.h>

int main()
{
  int n = 10;
  int sum = 0;
  int i = 1;

  loop:
    if (i > n)
    {
      goto end;
    }		

    sum += i*i;
    i += 1;
    goto loop;

  end:;

  printf("%i\n", sum);
}
{% endhighlight %}

## Programowanie strukturalne
Patrząc na powyższy przykład, można zauważyć, że wykorzystuje on tak zwaną instrukcję skoku ("goto"). Instrukcja ta nakazuje komputerowi, przy spełnieniu odpowiednich warunków,  przejście do odpowiedniej części programu i kontynowanie wykonywania programu od tego miejsca. Takie "skakanie" bardzo utrudnia analizę kodu. Paradygmat programowania strukturalnego ogranicza używanie instrukcji skoku, oraz definiuje strukturę kodu. Kod taki powinień składać się z kilku dobrze zdefiniowanych instrukcji:
* Sekwencja – wykonanie instrukcji jedna po drugiej
* Wybór – if-then-else
* Iteracja – for, while

Przykład obliczania sumy kwadratów liczb od 1 do n z użyciem powyższych instrukcji może wyglądać np. tak:

{% highlight c %}
#include <stdio.h>

int main()
{
  int n = 10;
  int sum = 0;
  for (int i = 1; i <= n; i++)
  {
    sum += i*i;
  }

  printf("%i\n", sum);
}
{% endhighlight %}

## Programowanie proceduralne
Głównym założeniem tego paradygmatu jest to aby kod dzielić na mniejsze kawałki, wykonujące jasno określone operacje. Większość języków wysokiego poziomu (a może wszystkie ;)) dostarczają konstrukcje zwane procedurami. W procedurach można zakodować poszczególne fragmenty programu, tak aby odseparować je od reszty, a także móc je wykorzystać w innych miejscach. Przykład podziału na procedury powyższego porgramu może wyglądać np. tak:

{% highlight c %}
#include <stdio.h>

int square(int i)
{
  return i*i;
}

int sumOfSquares(int n)
{
  int sum = 0;
  for (int i = 1; i <= n; i++)
  {
    sum += square(i);
  }

  printf("%i\n", sum);
}

int main()
{
  sumOfSquares(10);
}
{% endhighlight %}
